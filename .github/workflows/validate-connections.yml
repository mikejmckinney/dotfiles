# TEMPLATE_PLACEHOLDER: Update URLs and add database connection test for your project
#
# Daily Connection Validation
# ---------------------------
# Runs daily to verify backend API and database connectivity.
# Catches infrastructure issues before they affect users.
#
# Setup:
# 1. Set BACKEND_URL secret (e.g., https://your-app.onrender.com)
# 2. Set DATABASE_URL secret if using database health endpoint
# 3. Customize health check endpoints for your API

name: Validate Connections

on:
  schedule:
    # Run daily at 6:00 AM UTC
    - cron: '0 6 * * *'
  workflow_dispatch: # Allow manual trigger

jobs:
  validate:
    runs-on: ubuntu-latest
    
    steps:
      - name: Check backend API
        env:
          BACKEND_URL: ${{ secrets.BACKEND_URL }}
        run: |
          if [ -z "$BACKEND_URL" ]; then
            echo "âš ï¸ BACKEND_URL not configured - skipping API check"
            echo "Set BACKEND_URL as a repository secret to enable this check"
            exit 0
          fi
          
          echo "ðŸ” Checking backend API..."
          
          # Health endpoint check
          HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "${BACKEND_URL}/health" --max-time 30 || echo "000")
          
          if [ "$HEALTH_RESPONSE" = "200" ]; then
            echo "âœ… Health endpoint OK"
          else
            echo "âŒ Health endpoint returned: $HEALTH_RESPONSE"
            exit 1
          fi
          
          # Optional: API version check (customize endpoint)
          # VERSION_RESPONSE=$(curl -s "${BACKEND_URL}/api/version" --max-time 10)
          # echo "API Version: $VERSION_RESPONSE"

      - name: Check database connectivity
        env:
          BACKEND_URL: ${{ secrets.BACKEND_URL }}
        run: |
          if [ -z "$BACKEND_URL" ]; then
            echo "âš ï¸ Skipping database check - no BACKEND_URL"
            exit 0
          fi
          
          echo "ðŸ” Checking database connectivity..."
          
          # Option 1: Check via backend's DB health endpoint
          DB_HEALTH_URL="${BACKEND_URL}/health/db"
          DB_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$DB_HEALTH_URL" --max-time 30 || echo "000")
          
          if [ "$DB_RESPONSE" = "200" ]; then
            echo "âœ… Database connection OK"
          elif [ "$DB_RESPONSE" = "404" ]; then
            echo "âš ï¸ No /health/db endpoint - add one to your backend for better monitoring"
          else
            echo "âŒ Database health check failed: HTTP $DB_RESPONSE"
            exit 1
          fi

      # Optional: Direct database connectivity test (requires DB client)
      # - name: Direct database check
      #   env:
      #     DATABASE_URL: ${{ secrets.DATABASE_URL }}
      #   run: |
      #     if [ -z "$DATABASE_URL" ]; then
      #       echo "âš ï¸ DATABASE_URL not configured"
      #       exit 0
      #     fi
      #     # For PostgreSQL:
      #     # pg_isready -d "$DATABASE_URL"
      #     # For MySQL:
      #     # mysqladmin ping -h "$DB_HOST" -u "$DB_USER" -p"$DB_PASS"

      - name: Summary
        if: always()
        run: |
          echo "========================================"
          echo "Connection Validation Complete"
          echo "Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "========================================"

  notify-on-failure:
    runs-on: ubuntu-latest
    needs: validate
    if: failure()
    
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: Create issue on failure
        uses: actions/github-script@v7
        with:
          script: |
            const title = 'ðŸš¨ Daily Connection Validation Failed';
            const body = `The daily connection validation workflow failed.
            
            **Run:** ${context.runId}
            **Time:** ${new Date().toISOString()}
            
            Please check:
            1. Backend service status
            2. Database connectivity
            3. Network/DNS issues
            
            [View workflow run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`;
            
            // Check if similar issue already exists
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'infrastructure'
            });
            
            const existingIssue = issues.data.find(i => i.title === title);
            
            if (existingIssue) {
              // Add comment to existing issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `Another failure detected at ${new Date().toISOString()}\n\n[View run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`
              });
            } else {
              // Create new issue (labels are optional - will be ignored if they don't exist)
              try {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: title,
                  body: body,
                  labels: ['infrastructure', 'bug']
                });
              } catch (labelError) {
                // Retry without labels if they don't exist
                console.log('Labels not found, creating issue without labels');
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: title,
                  body: body
                });
              }
            }
